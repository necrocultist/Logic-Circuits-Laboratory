\documentclass[pdftex,12pt,a4paper]{article}
\usepackage{breakcites}
\usepackage{indentfirst}
\usepackage{pgfgantt}
\usepackage{pdflscape}
\usepackage{float}
\usepackage{epsfig}
\usepackage{epstopdf}
\usepackage[cmex10]{amsmath}
\usepackage{stfloats}
\usepackage{multirow}
\usepackage{mathtools}
\usepackage{karnaugh-map}
\usepackage{subfiles}
\usepackage{environ}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amssymb}
\theoremstyle{plain}
\usetikzlibrary{intersections}
\newlength{\crossing}
\makeatletter
\makeatother

\title{Lab - HW3}
\author{Kaan Karataş}
\date{April 2023}

\newcommand{\parts}[1]{
    \begin{figure}[H]
    	\centering
    	\includegraphics[width=1\textwidth]{codes/#1_code.png}
    	\caption{#1 Code}
    	\label{fig7}
        \end{figure}
    \begin{figure}[H]
    	\centering
    	\includegraphics[width=1\textwidth]{schematics/#1_schematic.png}
    	\caption{#1 Schematic}
    	\label{fig7}
        \end{figure}
    \begin{figure}[H]
    	\centering
    	\includegraphics[width=1\textwidth]{simulations/#1_test.png}
    	\caption{#1 Simulation}
    	\label{fig7}
\end{figure}
}

\thispagestyle{empty}
\begin{document}

\subfile{cover.tex}

\thispagestyle{empty}


\setcounter{tocdepth}{4}
\tableofcontents
\clearpage
\setcounter{page}{1}
\setcounter{subsubsection}{0}

\section{INTRODUCTION}
In this experiment, we have used three-state buffers to implement data buses and basic memory. For simulating the corresponding modules, Vivado is used. Lastly, Verilog is used to code and implement all the modules.

\section{HOMEWORK}
    \subsection{Three State Buffer}
        \parts{Three State Buffer}
    \subsection{Part 1}
    Three state buffer is used to implement an 8-bit bus. Changes to the selection input affect what is assigned to the output.
        \parts{Part 1}
    \subsection{Part 2}
    Specified Memory design containing a bus and two outputs with inputs is implemented in this part.
        \parts{Part 2}
    \subsection{Part 3}
    We have implemented an 8-bit memory line module. This module accepts 8-bit inputs and outputs 8-bit data. Additionally, the module accepts inputs for line selection, reset , write enable, read enable and clock for necessary operations. The module stores the data value that is provided as input when the write enable and line select inputs are high, at the rising edge of the clock signal. At the falling edge of the reset signal, the module erases the data that has been stored. The output of the module is the stored data if the inputs for read enable and line select are both high. The output has a high impedance if not.
        \parts{Part 3}
    \subsection{Part 4}
    Utilizing an 8-bit memory line module, an 8 byte memory module is implemented. The input and output of an 8-byte memory module are both 8-bit data. Inputs for the module's required operations include a 3-bit address, chip select, reset, read enable, write enable, and clock. When the chip select input is high, the Nth memory line is chosen. Address number N is shown here. If the write enable input is high, the chosen memory line stores the data that is input at the rising edge of the clock signal. At the falling edge of the reset signal, the module erases all data that has been stored in the memory lines. If the read enable input is high, the module's output is the data from the selected memory line. 
        \parts{Part 4}
    \subsection{Part 5}
        Implemented design is a 32 byte memory module using an 8 byte memory module. It accepts 8-bit data as input and outputs 8-bit data. This module also accepts inputs for a 5-bit address, reset, read enable, write enable, and clock. The remaining 3 bits of the address input are used to select the line, while the remaining 2 bits are used to select the chip. The same procedures as in Part 4 apply.
        \parts{Part 5}
    \subsection{Part 6}
        32-byte memory modules are used to implement 128-byte memory modules. 32-bit data is inputted into the 128-byte memory module and outputted in the same format. This module also accepts clock, address, reset, read enable, and write enable inputs. The same procedures as in Parts 4 and 5 apply. In order to implement 128 bytes of memory, 4 32-byte memories are utilized.
        \parts{Part 6}
    
\section{RESULTS}
Every memory and buss design in the homework assignment is implemented using Verilog. The test results are  the same with what we had predicted and expected before implementing modules. All test results are given on the relevant section.

\section{DISCUSSION}
Using Verilog programming language, we learned how complex memories work, implementing and using complex memory designs and busses throughout this homework. Our outcomes were fully in line with what we had anticipated.

\section{CONCLUSION}
With the help of the Verilog programming language, we were able to simulate data busses and basic memory components, succeeding in implementing them through this homework. To sum up, this was not a rather challenging homework for us compered to other assignments, and we were able to successfully complete all the parts.

\end{document}